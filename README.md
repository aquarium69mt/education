# education
Это личный проект изучения основ кодинга.   
This is a personal project learning the basics of coding.

Проект курирует /
Project curator https://github.com/lorodin


По вопросам и предложениям свяжитесь со мной:   
For question and suggestions, contact me:   
email: aquarium69mt@gmail.com

## **Задания**

**Вступление**

Код можно писать на любом языке, предпочтение к C/C++ из-за строгой типизации и очевидности возможных ошибок, которые будут видны еще на этапе компиляции.
Но самым лучшим и продуктивным будет реализация сразу на нескольких языках, на пример на C/C++ и PHP.

**1. Создать публичный репозиторий на github и рабочую локальную рабочую папку для него.**

1. Создать локальную папку, в которой будут храниться все выполненные задания.
2. Создать пустой публичный репозиторий на гитхабе, после его создания github расскажет, как привязать локальный репозиторий к только что созданному. На этом этапе можно просто скопипастить каждую команду и будет счастье, но лучше сразу прочитать, что каждая строка делает.

Почитать про ветвления веток, и другие базовые принципы для работы с системой контроля версий:  
https://git-scm.com/book/ru/v2/%D0%92%D0%B5%D1%82%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2-Git-%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-%D0%B2%D0%B5%D1%82%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F-%D0%B8-%D1%81%D0%BB%D0%B8%D1%8F%D0%BD%D0%B8%D1%8F

В завершение можно поэксперементировать с ветками, файлами. Разобраться, что такое .gitignore.
Все последующие задания необходимо реализовать в этой директории в отдельных ветках, имя веток - транслейт названия задания

**2. Сортировка массива**

Необходимо реализовать функцию, которая в качестве аргументов принимает ссылку на массив сущностей пользователя (в случае с C еще и его длину) и производит его сортировку по ID.
Пример структуры пользователя:

```c
// Пример на С
 
 
// Импортируем библиотеку для печати в консоль
#include <iostream>
// Имортируем библиотеку для работы со строками
#include <string>
 
// Устанавливаем пространство имен по умолчанию
// (пока не парься, что это, просто надо)
using namespace std;
 
// Описание структуры пользователя
struct User {
   int ID;
   string name;
   int age;
};
 
// Семантика функции, которую нужно реализовать
// users - массив пользователей
// N - размер массива
void sort(User* users, int N)
{
   // Твой код здесь
}
 
void print(User* users, int N)
{
   for (int i = 0; i < N; i++) {
       cout << "users[" << i << "] = { ID: " << users[i].ID << ",  name: " << users[i].name << ", age = " << users[i].age << " }"<< endl;
   }
}
 
int main() {
   User users[10] = {
           {10, "Игорь",    23},
           {3,  "Вася",     17},
           {1,  "Елена",    18},
           {9,  "Ольга",    20},
           {7,  "Выктор",   33},
           {6,  "Лариса",   21},
           {4,  "Гена",     48},
           {2,  "Олег",     24},
           {5,  "Женя",     32},
           {8,  "Кристина", 13}
   };
 
   sort(users, 10);
 
   print(users, 10);
 
   return 0;
}
```
```php
<?php
 
// Пример на PHP
 
class User {
   public $id;
   public $name;
   public $age;
 
   public function __construct($id, $name, $age) {
       $this->id = $id;
       $this->name = $name;
       $this->age = $age;
   }
}
 
function printUsers($users)
{
   for ($i = 0; $i < count($users); $i++) {
       echo "users[" . $i . "] = { ID: " . $users[$i]->id .
            ", name: " . $users[$i]->name .
            ", age: " . $users[$i]->age . " }" . PHP_EOL;
   }
}
 
function sortUsers(&$users)
{
   // Надо реализовать сортировку
}
 
 $users = [
   new User(10, "Игорь", 23),
   new User(3, "Вася", 17),
   new User(1, "Елена", 18),
   new User(9, "Ольга", 20),
   new User(7, "Виктор", 33),
   new User(6, "Лариса", 21),
   new User(4, "Гена", 48),
   new User(2, "Олег", 24),
   new User(5, "Женя", 32),
   new User(8, "Кристина", 13)
 ];
 
 
 sortUsers($users);
 
 printUsers($users);
```

**3. Создание вспомогательного массива для сортировки**

В предыдущем задание сортировка массива производилась по одному полю и порядок элементов в исходном массиве изменялся. Но чаще всего требуется сортировать набор данных по разным полям одновременно, при этом необходимо, чтобы последовательность элементов в массиве оставалась неизменной.
Для этого используются так называемые индексы, если говорить о базах данных, или вспомогательные массивы, если говорить о программной реализации.
Для примера, есть исходный целочисленный массив:

`int arr[] = {3, 2, 4, 1}`

Необходимо отсортировать этот массив, но при этом, не изменять исходный массив. Создадим новый массив того же размера, изначально пусть элементы массива хранят индекс соответсвующих элементов:

`int indexes[] = {0, 1, 2, 3}`

Таким образом, сейчас мы можем ссылаться на элементы первого массива (arr) через элементы второго:

`arr[0] == arr[indexes[0]]`     
Еще для выполнения задания на C/C++ нужно знать так конструкцию, как enum (перечисление). Эта конструкция похожа на класс с публичными статичными полями, либо же на именованный набор констант, в нашем случае enum будет выглядеть следующим образом:


 ```c
 enum OrderProperty {
   ID,
   AGE
 };
 ```

В дальнейшем к ID и AGE можно будет обращаться через имя `enum-а: OrderProperty::ID, OrderProperty::AGE.`

**Задание**

Нужно реализовать функцию, которая будет возвращать указатель на массив с индексами отсортированными по возрастанию, в зависимости от значения enum-а, переданного также в качестве аргумента.

 ```c
 int* createIndexes(User* users, int n, OrderProperty orderBy);
 ```

Первым аргументом функция принимает массив пользователей, вторым аргументом размер этого массива, третий аргумент, имя поля, по которому требуется выполнить сортировку (OrderProperty::ID или OrderProperty::AGE)

*Примечание*    
Создать указатель на массив нужной длины можно с помощью malloc:


 ```c
 int* pData = reinterpret_cast<int*>(malloc(sizeof(int) * n));  
 ```

malloc - функция, выделяющая память в куче, и возвращающая на нее указатель. Функция принимает в качестве аргумента размер необходимой памяти, в нашем случае `sizeof(int) * n, sizeof(int)` - Вернет размер в байтах для типа integer в текущей системе, и умножаем этот размер на количество элементов в массиве (n).
`reiterpret_cast<type>` - Эта функция преобразует тип аргумента, к типу указанному в угловых скобках. Так как функция malloc возвращает указатель типа void*, необходимо его преобразовать к указателю int*


*Пожелание*     
Выполнить это задание на C/C++ и на PHP.

**4. Связный список**

По аналогии со списком, который мы реализовали для типа int, нужно создать список, который будет работать с типом User, созданным в предыдущих заданиях.
Каждый элемент списка должен хранить указатель на пользователя и указатель на следующий элемент.
``` c
struct NodeUser {
   User* user;
   NodeUser* next;
}
```


Создать функцию добавления пользователя в список.

```c
void addNewUser(NodeUser* head, string name, int age);
``` 

Эта функция должна создать нового пользователя и добавить его в конец списка.
ID нового пользователя должен равняться максимальному ID в списке, увеличенному на 1, такой подход к формированию ID будет гарантировать, что все идентификаторы пользователей уникальны.

**5. Стек, очередь.**

Для списка из предыдущего задания необходимо реализовать методы, позволяющие работать со списком по принципу очереди (первый пришел, первый вышел), и по принципу стека (первым пришел, последним вышел).








```c 
// Добавляет пользователя в конец списка
void add(NodeUser* head, User* user);
 
// Возвращает указатель на первого пользователя и удаляет этот элемент из списка (Важно! Элемент удаляется только из списка, очищать за ним память не нужно)
User* get(NodeUser* head);
 
// Возвращает указатель на последнего добавленного пользователя и удаляет этот элемент из списка (Важно! Элемент удаляется только из списка, очищать за ним память не нужно)
User* pop(NodeUser* head);
``` 


**6. Бинарное-сортирующие дерево*****

Это задание со звездочками, на самом деле ничего сложного, просто тут потребуется собрать воедино все знания по сортировкам и структурам данных, которые, скорее всего, уже появились.

*Бинарное дерево*   
С математической точки зрения, это ацикличный граф, как правило ориентированный (связи между элементами имеют направление), каждый элемент дерева имеет не более одно родительского узла (у корневого элемента их 0), и не более двух дочерних узлов.
С точки зрения реализации бинарного дерева в программирование, это структура данных, которая хранит в себе левый и правый дочерние элементы.
На Рисунке 1. изображена схема бинарного дерева. Одно из полей AnyValue может хранить любое значение, также оно не обязательно должно быть одно. LeftNode и RightNode указывают на левое и правое поддеревья для текущего узла.

Бинарные деревья очень часто используются в программирование, их популярность связана со скоростью обработки данных, которые в них содержутся. В бинарном дереве поиска, для поиска элемента требуется максимум O(log(N)) операций, так как при каждом сравнение можно исключить половину ненужных элементов. Главное требование, которое сказывается на производительности поиска в бинарном дереве, это его сбалансированность. Из названия можно понять, что это значит, дерево является полностью сбалансированным, если для любого узла, в любом направление (правом или левом), всегда одинаковое количество потомков, или уровней иерархии. Так, на пример, если у каждого узла дерева отсуствует правый элемент, но есть левый (кроме последнего потомка, у него вообще нет дочерних элементов), то бинарное дерево поиска вырождается в обычный односвязный отсортированный список, и худшее время поиска в нем упрется в сложность O(N). **Важно!** Если что-то не понятно со структурами данных, то рисуй! Зарисовывай деревья, представляй, как бы ты вставлял туда элементы, как бы их удалял оттуда.
![Alt-текст](https://lh3.googleusercontent.com/keep-bbsk/AGk0z-Mn6tgSQeU8JuIP_siTO6AAdacz_LUXE7FpkXkhcxk9verSo4rezpbTwAZbcRjfIdU0GfB2b5MXBxcg9d5ErX4ko7jHXVwI1fhtivY=s811 "Бинарное дерево")





Рис 1. Бинарное дерево

*Бинарное сортирующее дерево*

Для того чтобы эффективно выполнять поиск по отсортированному набору данных, в первую очередь этот набор данных необходимо отсортировать. В предыдущих заданиях уже была реализована самая простая сортировка, сложность которой O(N^2), эта сортировка проста в реализации, но очень сложна с точки зрения выполнения.
При N = 1000000 (10^6 миллион элементов в массиве) этот алгоритм уже становится нерабочим, т.к. N^2 = 1000000000000 - столько операций потребуется сделать компьютеру, чтобы отсортировать этот массив. А это для процессора с частотой в 2Ггц, 10^12/(2 * 10^9) = 500 секунд, или без малого 10 минут, при этом данный алгоритм невозможно распараллелить, он должен выполняться последовательно, а значит сколько бы ядер не было на процессоре, сортировка будет крайне медленной.
Есть несколько алгоритмов, позволяющих выполнять сортировку за O(N*log(N)), мы разберем один из них, с помощью бинарного дерева. (для справки, при N = 10^6, N*log(N) ~ 2 * 10^7, что всего на один порядок больше N, и сортировка займет меньше одной секунды на процессоре с частотой в 2Ггц).

Для реализации этого алгоритма нам в первую очередь понадобиться структура, позволяющая построить бинарное дерево сортировки. Для сортировки, в отличии от поиска, нам не нужно делать сбалансированное дерево, что очень сильно упрощает алгоритм, и делает сложность построения дерева линейным (т.е. потребуется N операций для его построения).

Структура для бинарного дерева может иметь следующий вид:

```c 
struct TreeNode {
   int value;
   TreeNode* left;
   TreeNode* right;
}
```

По аналогии со списком, нам нужен метод, который будет добавлять новые дочерние элементы:

``` c
void addNewItem(TreeNode* rootItem, int value);
``` 

Но в отличии от списка, в этом методе необходимо будет определять, в каком поддереве создавать новый элемент:
1. Если значение value больше, либо равно, значению rootItem->value то добавляем новый элемент в правое поддерево.
2. Если значение value меньше значение rootItem->value, то добавляем в левое поддерево.

После построения дерева, необходимо преобразовать дерево в массив. Семантика этой функции будет следующая:
```c 
void treeToArray(TreeNode* root, int* result);
``` 

Первым аргументов в метод передается корневой узел, вторым аргументом передается указатель на итоговый массив, который должен быть заполнен в этом методе.

Подсказка. Все методы по работе с деревом будет проще всего реализовать с помощью рекурсии. Если есть проблему с пониманием, то рисуй! Рисуй до тех пор пока не станет понятно, и только после этого переходи к коду!

В итоге код метода main должен иметь примерно такой вид:


```c 
int main()
{
   // Создаем произвольный не отсортированный массив
   int data[6] = {3, 2, 1, 4, 5, 3};
   // Создаем пустой указатель на корневой элемент
   TreeNode *root = nullptr;
 
   // Через цикл добавляем все элементы массива в дерево
   for (int i = 0; i < 6; i++) {
       // В этом методе уже должна строится структура дерева
       addNewItem(root, data[i]);
   }
 
   // Создаем пустой массив из 6 элементов, куда сохраним результат
   int* result = reinterpret_cast<int*>(malloc(sizeof(int) * 6));
 
   // Записываем дерево в массив
   // Элементы в массив в этом методе должно уже попадать отсортированными
   treeToArray(root, result);
 
 
   // Выводим отсортированный массив на экран
   for (int i = 0; i < 6; i++) {
       cout << result[i] << " " << endl;
   }
}
``` 



